class Test_tools {

	/*
	 * 常见知识点
	 */
	public static void record() {

		String strs = String.valueOf(66.777);// 转换

		int index = strs.indexOf(".");// 返回字符的位置

		String str = strs.substring(0, 5);// 返回[0,5)
		str = strs.substring(6, 7);// 返回[6,7) 个字符
		str = strs.substring(6);// 返回从第[6,...到最后

		String ip = "192.168.1.1";// .的切分加\\
		String a[] = ip.split("\\.");

		System.out.printf("%.6f\n", 66.66666666);// 四舍五入第6个小数点
		// 另一种方法
		DecimalFormat df = new DecimalFormat("#.00");
		System.out.println(df.format(66.6666));

		Map<String, Integer> map = new HashMap<>();
		// 遍历value
		for (Integer n : map.values()) {
			System.out.println(n);
		}
		// 遍历key
		for (String m : map.keySet()) {
			System.out.println(m);
		}
		// map.entrySet()
		for (Map.Entry<String, Integer> entry : map.entrySet()) {
			System.out.println(entry.getKey() + " " + entry.getValue());
		}
		// Iterator map.keySet()
		Iterator<String> it = map.keySet().iterator();
		while (it.hasNext()) {
			System.out.println(map.get(it.next()));
		}
		// Iterator map.entrySet()
		Iterator<Map.Entry<String, Integer>> it1 = map.entrySet().iterator();
		while (it1.hasNext()) {
			System.out.println(it1.next().getKey() + " " + it1.next().getValue());
		}

		// 数组转字符串[1,2,3]
		int[] arrInt = { 1, 2, 3 };
		Arrays.toString(arrInt);

		// list转Array
		List<String> list = new ArrayList<String>();
		String[] array = (String[]) list.toArray();
		// 推荐方法
		array = list.toArray(new String[list.size()]);

		// 数组转list
		String[] array1 = { "java", "c" };
		List<String> list1 = Arrays.asList(array1);// 返回的list是Arrays里面的一个静态内部类，该类并未实现add,remove方法，因此在使用时存在局限性
		// 推荐方法
		list1 = new ArrayList<String>(Arrays.asList(array));
		// addall方法
		List<String> list2 = new ArrayList<String>(array.length);
		Collections.addAll(list, array);

		// 列表删除的三种方法
		List<String> list3 = new ArrayList<>();
		list.add("aa");
		list.add("bb");
		list.add("cc");
		// 使用迭代器
		Iterator<String> it3 = list.iterator();
		while (it.hasNext()) {
			String str1 = (String) it.next();
			if ("aa".equals(str1)) {
				it.remove();
			}
		}
		// 末尾开始
		for (int i = list.size() - 1; i >= 0; i--) {
			String str1 = list.get(i);
			if ("aa".equals(str1)) {
				list.remove(str1);
			}
		}
		// 使用CopyOnWriteArrayList
		CopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<String>(list3);
		for (String str1 : cowList) {
			if ("aa".equals(str1)) {
				cowList.remove(str1);
			}
		}

		// Character.isDigit( char ch ) 判断ch是否是数字字符，如'1'，'2‘，是返回true。否则返回false
		boolean flag = Character.isDigit('1');
		// 判断ch是否是字母字符，如'a'，'b‘，是返回true
		flag = Character.isLowerCase('1') || Character.isUpperCase('1');
		// 判断ch是否是字母或数字字符，如'a'，'b‘，'1'，'2'，是返回true。否则返回false
		flag = Character.isLetterOrDigit('a');

		// 字符串大小写切换
		String str2 = "aaaaaBBcccc";
		String Upstr = str2.toUpperCase();
		String Lowstr = str2.toLowerCase();

		// clone复制数组
		int[] a1 = { 1, 3 };
		int[] a2 = a1.clone();

		// System.arraycopy复制数组
		int[] a3 = { 1, 2, 3, 4, 5 };
		int[] a4 = new int[10];
		System.arraycopy(a3, 1, a4, 3, 3);

		// Arrays.copyOf
		int[] a5 = { 1, 2, 3, 4, 5 };
		int[] a6 = Arrays.copyOf(a1, 3);// Arrays.copyOf(a1, arr.length)

		// Arrays.copyOfRange
		int[] a7 = { 1, 2, 3, 4, 5 };
		int[] a8 = Arrays.copyOfRange(a1, 0, 1);

		// str.substring(start,stop) [start,stop)
		str = "0123456789";
		str.substring(2, 5);// "234"

		BigDecimal num1 = new BigDecimal(0.005);
		BigDecimal num2 = new BigDecimal(1000000);
		BigDecimal num3 = new BigDecimal(-1000000);
		// 尽量用字符串的形式初始化
		BigDecimal num12 = new BigDecimal("0.005");
		BigDecimal num22 = new BigDecimal("1000000");
		BigDecimal num32 = new BigDecimal("-1000000");

		// 加法
		BigDecimal result1 = num1.add(num2);
		BigDecimal result12 = num12.add(num22);
		// 减法
		BigDecimal result2 = num1.subtract(num2);
		BigDecimal result22 = num12.subtract(num22);
		// 乘法
		BigDecimal result3 = num1.multiply(num2);
		BigDecimal result32 = num12.multiply(num22);
		// 绝对值
		BigDecimal result4 = num3.abs();
		BigDecimal result42 = num32.abs();
		// 除法
		BigDecimal result5 = num2.divide(num1, 20, BigDecimal.ROUND_HALF_UP);
		BigDecimal result52 = num22.divide(num12, 20, BigDecimal.ROUND_HALF_UP);

	}

	// ---------------------------------------------------------字符串逆序始-----------------------------------------------------

	// 利用StringBuffer的内置reverse方法进行逆序排序
	public static String reverse1(String str) {
		return new StringBuffer(str).reverse().toString();
	}

	// 从头部开始,正序:通过字符串数组实现从尾部开始esrever顺序逐个进入字符串reverse
	public static String reverse2(String str) {
		int len = str.length();
		String reverse = "";
		for (int i = 0; i < len; i++) {
			reverse = str.charAt(i) + reverse;
		}
		return reverse;
	}

	// 从尾部开始,倒序
	public static String reverse3(String str) {
		char[] arr = str.toCharArray();
		String reverse = "";
		for (int i = arr.length; i >= 0; i--) {
			reverse += arr[i];
		}
		return reverse;
	}

	// 利用栈:First In Last Out
	// java中不用手动销毁
	public static String reverse4(String str) {
		StringBuffer sb = new StringBuffer();
		Stack<Character> stack = new Stack<Character>();// 创建只装字符型的stack

		for (int i = 0; i < str.length(); i++)
			stack.add(str.charAt(i));

		for (int i = 0; i < str.length(); i++)
			sb.append(stack.pop());// 出栈，StringBuffer.append()添加到sb的缓冲区末端；.insert(int index,添加的内容)添加到指定位置

		return sb.toString();
	}

	// 二位进制的右移，利用临时变量进行交换
	public static String reverse5(String str) {
		StringBuffer sb = new StringBuffer(str);

		for (int i = 0, j = sb.length() - 1; i < sb.length() >>> 1; i++, j--) { // 右移>>
			char temp = sb.charAt(i);
			sb.setCharAt(i, sb.charAt(j)); // setCharAt(int index取代的位置, Char ch要替换为的字符串)
			sb.setCharAt(j, temp);

		}
		return sb.toString();
	}

	// 递归
	public static String reverse6(String str) {
		int len = str.length();
		if (len <= 1)
			return str;

		String left = str.substring(0, len / 2);
		String right = str.substring(len / 2, len);

		return reverse6(right) + reverse6(left);

	}

	// 异或^
	public static String reverse7(String str) {
		char[] s = str.toCharArray();
		int begin = 0;
		int end = str.length() - 1;
		while (begin < end) {
			s[begin] = (char) (s[begin] ^ s[end]);
			System.out.println("第一次^ : " + s[begin] + s[end]);
			s[end] = (char) (s[begin] ^ s[end]); // s[begin] 被 s[end]异或两次，得到s[begin] 赋值给s[end]
			System.out.println("第二次^ : " + s[begin] + s[end]);
			s[begin] = (char) (s[end] ^ s[begin]);
			System.out.println("第三次^ : " + s[begin] + s[end]); // 换位成功
			begin++;
			end--;
		}
		return new String(s);
	}

	// ---------------------------------------------------------字符串逆序终-----------------------------------------------------

	// ---------------------------------------------------------rm1始-----------------------------------------------------

	/**
	 * 二分查找数据局部最小值
	 * 
	 * @param arr
	 * @return
	 */
	public static int getLessIndex(int[] arr) {
		if (arr == null || arr.length == 0) {
			return -1; // no exist
		}
		if (arr.length == 1 || arr[0] < arr[1]) {
			return 0;
		}
		if (arr[arr.length - 1] < arr[arr.length - 2]) {
			return arr.length - 1;
		}
		int left = 1;
		int right = arr.length - 2;
		int mid = 0;
		while (left < right) {
			mid = (left + right) / 2;
			if (arr[mid] > arr[mid - 1]) {
				right = mid - 1;
			} else if (arr[mid] > arr[mid + 1]) {
				left = mid + 1;
			} else {
				return mid;
			}
		}
		return left;
	}

	/**
	 * 递归查找最大值
	 * 
	 * @param arr
	 * @param L
	 * @param R
	 * @return
	 */
	public static int getMax(int[] arr, int L, int R) {
		if (L == R) {
			return arr[L];
		}
		int mid = L + ((R - L) >> 1);
		int leftMax = getMax(arr, L, mid);
		int rightMax = getMax(arr, mid + 1, R);
		return Math.max(leftMax, rightMax);
	}

	/**
	 * 一个奇数一个偶数其他全是偶数数组求奇数和偶数
	 * 
	 * @param arr
	 */
	public static void printOddTimesNum2(int[] arr) {
		int eO = 0, eOhasOne = 0;
		for (int curNum : arr) {
			eO ^= curNum;
		}
		int rightOne = eO & (~eO + 1);
		for (int cur : arr) {
			if ((cur & rightOne) != 0) {
				eOhasOne ^= cur;
			}
		}
		System.out.println(eOhasOne + " " + (eO ^ eOhasOne));
	}

	/**
	 * 一个奇数其他全偶数数组求奇数
	 * 
	 * @param arr
	 */
	public static void printOddTimesNum1(int[] arr) {
		int eO = 0;
		for (int cur : arr) {
			eO ^= cur;
		}
		System.out.println(eO);
	}

	// 在可能重复arr上，找满足>=value的最左位置
	public static int nearestIndex(int[] arr, int value) {
		int L = 0;
		int R = arr.length - 1;
		int index = -1;
		while (L < R) {
			int mid = L + ((R - L) >> 1);
			if (arr[mid] >= value) {
				index = mid;
				R = mid - 1;
			} else {
				L = mid + 1;
			}
		}
		return index;
	}

	/**
	 * 数组二分查找
	 * 
	 * @param sortedArr
	 * @param num
	 * @return
	 */
	public static boolean exist(int[] sortedArr, int num) {
		if (sortedArr == null || sortedArr.length == 0) {
			return false;
		}
		int L = 0;
		int R = sortedArr.length - 1;
		int mid = 0;
		while (L < R) {
			mid = L + ((R - L) >> 1);
			if (sortedArr[mid] == num) {
				return true;
			} else if (sortedArr[mid] > num) {
				R = mid - 1;
			} else {
				L = mid + 1;
			}
		}
		return sortedArr[L] == num;
	}

	/**
	 * 插入排序
	 * 
	 * @param arr
	 */
	public static void insertionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		for (int i = 1; i < arr.length; i++) {
			for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
				swap(arr, j, j + 1);
			}
		}
	}

	/**
	 * 冒泡排序
	 * 
	 * @param arr
	 */
	public static void bubbleSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		for (int e = arr.length - 1; e > 0; e--) {
			for (int i = 0; i < e; i++) {
				if (arr[i] > arr[i + 1]) {
					swap(arr, i, i + 1);
				}
			}
		}
	}

	/**
	 * 选择排序
	 * 
	 * @param arr
	 */
	public static void selectionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		for (int i = 0; i < arr.length - 1; i++) {
			int minIndex = i;
			for (int j = i + 1; j < arr.length; j++) {
				minIndex = arr[j] < arr[minIndex] ? j : minIndex;
			}
			swap(arr, i, minIndex);
		}
	}

	/**
	 * 交换数组中的值
	 * 
	 * @param arr
	 * @param i
	 * @param j
	 */
	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}

	/**
	 * 异或方式交换数组
	 * 
	 * @param arr
	 * @param i
	 * @param j
	 */
	public static void swapXor(int[] arr, int i, int j) {
		arr[i] = arr[i] ^ arr[j];
		arr[j] = arr[i] ^ arr[j];
		arr[i] = arr[i] ^ arr[j];
	}

	/**
	 * 数组排序（java自带sort）
	 * 
	 * @param arr
	 */
	public static void comparator(int[] arr) {
		Arrays.sort(arr);
	}

	/**
	 * 随机生成maxSize长度的值为maxValue以内的正负数的数组
	 * 
	 * @param maxSize
	 * @param maxValue
	 * @return
	 */
	public static int[] generateRandomArray(int maxSize, int maxValue) {
		int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
		}
		return arr;
	}

	/**
	 * 复制数组
	 * 
	 * @param arr
	 * @return
	 */
	public static int[] copyArray(int[] arr) {
		if (arr == null) {
			return null;
		}
		int[] res = new int[arr.length];
		for (int i = 0; i < arr.length; i++) {
			res[i] = arr[i];
		}
		return res;
	}

	/**
	 * 判断int数组是否相等
	 * 
	 * @param arr1
	 * @param arr2
	 * @return
	 */
	public static boolean isEqual(int[] arr1, int[] arr2) {
		if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
			return false;
		}
		if (arr1 == null && arr2 == null) {
			return true;
		}
		if (arr1.length != arr2.length) {
			return false;
		}
		for (int i = 0; i < arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * 打印数组
	 * 
	 * @param arr
	 */
	public static void printArray(int[] arr) {
		if (arr == null) {
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	/**
	 * 测试方法
	 * 
	 * @param args
	 */
	public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 100;
		int maxValue = 100;
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr1 = generateRandomArray(maxSize, maxValue);
			int[] arr2 = copyArray(arr1);
			selectionSort(arr1);
			comparator(arr2);
			if (!isEqual(arr1, arr2)) {
				succeed = false;
				printArray(arr1);
				printArray(arr2);
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Bad!");

		int[] arr = generateRandomArray(maxSize, maxValue);
		printArray(arr);
		selectionSort(arr);
		printArray(arr);

		String str = "123";
		str = reverse6(str);
		System.out.println(str);
	}
	// ---------------------------------------------------------rm1终-----------------------------------------------------

	// ---------------------------------------------------------rm2始-----------------------------------------------------

	/**
	 * 归并排序
	 * 
	 * @param arr
	 */
	public static void mergeSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		mergeSort(arr, 0, arr.length - 1);
	}

	public static void mergeSort(int[] arr, int l, int r) {
		if (l == r) {
			return;
		}
		int mid = l + ((r - l) >> 1);
		mergeSort(arr, l, mid);
		mergeSort(arr, mid + 1, r);
		merge(arr, l, mid, r);
	}

	/**
	 * 有序数组合并
	 */
	public static void merge(int[] arr, int l, int m, int r) {
		int[] help = new int[r - l + 1];
		int i = 0;
		int p1 = l;
		int p2 = m + 1;
		while (p1 <= m && p2 <= r) {
			help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
		}
		while (p1 <= m) {
			help[i++] = arr[p1++];
		}
		while (p2 <= r) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[l + i] = help[i];
		}
	}

	/**
	 * 计算小和
	 * 
	 * @param arr
	 * @return
	 */
	public static int smallSum(int[] arr) {
		if (arr == null || arr.length < 2) {
			return 0;
		}
		return mergeSort1(arr, 0, arr.length - 1);
	}

	public static int mergeSort1(int[] arr, int l, int r) {
		if (l == r) {
			return 0;
		}
		int mid = l + ((r - l) >> 1);
		return mergeSort1(arr, l, mid) + mergeSort1(arr, mid + 1, r) + merge1(arr, l, mid, r);
	}

	/**
	 * 合并有序数组做特殊处理
	 */
	public static int merge1(int[] arr, int l, int m, int r) {
		int[] help = new int[r - l + 1];
		int i = 0;
		int p1 = l;
		int p2 = m + 1;
		int res = 0;
		while (p1 <= m && p2 <= r) {
			res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] : 0;
			help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
		}
		while (p1 <= m) {
			help[i++] = arr[p1++];
		}
		while (p2 <= r) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[l + i] = help[i];
		}
		return res;
	}

	// 逆序对 暴力简单低效，不会改变原数组
	public static int inversePairs(int[] array) {
		if (array == null || array.length < 2) {
			return 0;
		}
		int count = 0;
		for (int i = 0; i < array.length; i++) {
			for (int j = i + 1; j < array.length; j++) {
				if (array[i] > array[j]) {
					count++;
				}
			}
		}
		return count % 1000000007;
	}

	// 利用数组的归并排序，高效，但是会改变原数组
	public static int inversePairs2(int[] array) {
		if (array == null || array.length < 2) {
			return 0;
		}
		int count = mergeSort2(array, 0, array.length - 1);
		return count % 1000000007;
	}

	private static int mergeSort2(int[] array, int start, int end) {
		if (start >= end) {
			return 0;
		}
		// 找到数组的中点，分割为两个子数组，递归求解
		int mid = (start + end) / 2;
		int left = mergeSort2(array, start, mid);
		int right = mergeSort2(array, mid + 1, end);

		// 存储归并后的数组
		int[] copy = new int[array.length];
		System.arraycopy(array, start, copy, start, end - start + 1);
		// 从两个子数组的尾部开始遍历
		int i = mid;
		int j = end;
		int copyIndex = end;
		// 记录逆序对的数量
		int count = 0;

		while (i >= start && j >= mid + 1) {
			// 数组是升序的
			// 如果左边数组比右边数组大，则将大的放入存储数组中
			// 并且累加逆序对，应为是有序的，所以左边数组的第i个元素比第j个及其之前的数都大
			if (array[i] > array[j]) {
				copy[copyIndex--] = array[i--];
				count += j - mid;
			} else {
				copy[copyIndex--] = array[j--];
			}
		}

		// 将子数组剩余的部分一次写入归并后的存储数组
		while (i >= start) {
			copy[copyIndex--] = array[i--];
		}
		while (j >= mid + 1) {
			copy[copyIndex--] = array[j--];
		}

		// 将本次两个子数组的合并写入原数组中
		for (int k = start; k <= end; k++) {
			array[k] = copy[k];
		}
		return left + right + count;
	}

	/**
	 * 堆排序
	 */
	public static void heapSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			heapInsert(arr, i);
		}
		int size = arr.length;
		swap(arr, 0, --size);
		while (size > 0) {
			heapify(arr, 0, size);
			swap(arr, 0, --size);
		}
	}

	/**
	 * 构建堆（通过一个个的插入）
	 */
	public static void heapInsert(int[] arr, int index) {
		while (arr[index] > arr[(index - 1) / 2]) {
			swap(arr, index, (index - 1) / 2);
			index = (index - 1) / 2;
		}
	}

	/**
	 * 调整堆
	 */
	public static void heapify(int[] arr, int index, int size) {
		int left = index * 2 + 1;
		while (left < size) {
			int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;
			largest = arr[largest] > arr[index] ? largest : index;
			if (largest == index) {
				break;
			}
			swap(arr, largest, index);
			index = largest;
			left = index * 2 + 1;
		}
	}

	/**
	 * 几乎有序数组，移动距离不超过K进行排序
	 */
	public void sortedArrDistanceLessK(int[] arr, int k) {
		PriorityQueue<Integer> heap = new PriorityQueue<>();
		int index = 0;
		for (; index < Math.min(arr.length, k); index++) {
			heap.add(arr[index]);
		}
		int i = 0;
		for (; index < arr.length; i++, index++) {
			heap.add(arr[index]);
			arr[i] = heap.poll();
		}
		while (!heap.isEmpty()) {
			arr[i++] = heap.poll();
		}
	}

	/**
	 * 荷兰国旗问题
	 */
	public static int[] partition(int[] arr, int l, int r, int p) {
		int less = l - 1;
		int more = r + 1;
		while (l < more) {
			if (arr[l] < p) {
				swap(arr, ++less, l++);
			} else if (arr[l] > p) {
				swap(arr, --more, l);
			} else {
				l++;
			}
		}
		return new int[] { less + 1, more - 1 };
	}

	/**
	 * 快排（随机选择位置）
	 */
	public static void quickSort(int[] arr, int l, int r) {
		if (l < r) {
			swap(arr, l + (int) (Math.random() * (r - l + 1)), r);
			int[] p = partition(arr, l, r);
			quickSort(arr, l, p[0] - 1);
			quickSort(arr, p[1] + 1, r);
		}
	}

	public static int[] partition(int[] arr, int l, int r) {
		int less = l - 1;
		int more = r;
		while (l < more) {
			if (arr[l] < arr[r]) {
				swap(arr, ++less, l++);
			} else if (arr[l] > arr[r]) {
				swap(arr, --more, l);
			} else {
				l++;
			}
		}
		swap(arr, more, r);
		return new int[] { less + 1, more };
	}

	// ---------------------------------------------------------rm2终-----------------------------------------------------

	// ---------------------------------------------------------rm3始-----------------------------------------------------

	// 计数排序 only for 0~200 value
	public static void countSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < arr.length; i++) {
			max = Math.max(max, arr[i]);
		}
		int[] bucket = new int[max + 1];
		for (int i = 0; i < arr.length; i++) {
			bucket[arr[i]]++;
		}
		int i = 0;
		for (int j = 0; j < bucket.length; j++) {
			while (bucket[j]-- > 0) {
				arr[i++] = j;
			}
		}
	}

	// 基数排序 only for no-negative value
	public static void radixSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		radixSort(arr, 0, arr.length - 1, maxbits(arr));
	}

	public static int maxbits(int[] arr) {
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < arr.length; i++) {
			max = Math.max(max, arr[i]);
		}
		int res = 0;
		while (max != 0) {
			res++;
			max /= 10;
		}
		return res;
	}

	public static void radixSort(int[] arr, int begin, int end, int digit) {
		final int radix = 10;
		int i = 0, j = 0;

		int[] bucket = new int[end - begin + 1];
		for (int d = 1; d <= digit; d++) {
			int[] count = new int[radix];
			for (i = begin; i <= end; i++) {
				j = getDigit(arr[i], d);
				count[j]++;
			}
			for (i = 1; i < radix; i++) {
				count[i] = count[i] + count[i - 1];
			}
			for (i = end; i >= begin; i--) {
				j = getDigit(arr[i], d);
				bucket[count[j] - 1] = arr[i];
				count[j]--;
			}
			for (i = begin, j = 0; i <= end; i++, j++) {
				arr[i] = bucket[j];
			}
		}
	}

	public static int getDigit(int x, int d) {
		return ((x / ((int) Math.pow(10, d - 1))) % 10);
	}
	// ---------------------------------------------------------rm3终-----------------------------------------------------

	// ---------------------------------------------------------rm4始-----------------------------------------------------

	// 单链表节点
	public static class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	// 反转单链表
	public static Node reverseList(Node head) {
		Node pre = null;
		Node next = null;
		while (head != null) {
			next = head.next;
			head.next = pre;
			pre = head;
			head = next;
		}
		return pre;
	}

	// 双链表
	public static class DoubleNode {
		public int value;
		public DoubleNode last;
		public DoubleNode next;

		public DoubleNode(int data) {
			this.value = data;
		}
	}

	// 反转双链表
	public static DoubleNode reverseList(DoubleNode head) {
		DoubleNode pre = null;
		DoubleNode next = null;
		while (head != null) {
			next = head.next;
			head.next = pre;
			head.last = next;
			pre = head;
			head = next;
		}
		return pre;
	}

	// 打印单链表
	public static void printLinkedList(Node head) {
		System.out.print("Linked List: ");
		while (head != null) {
			System.out.print(head.value + " ");
			head = head.next;
		}
		System.out.println();
	}

	// 打印双链表
	public static void printDoubleLinkedList(DoubleNode head) {
		System.out.print("Double Linked List: ");
		DoubleNode end = null;
		while (head != null) {
			System.out.print(head.value + " ");
			end = head;
			head = head.next;
		}
		System.out.print("| ");
		while (end != null) {
			System.out.print(end.value + " ");
			end = end.last;
		}
		System.out.println();
	}

	// 打印单链表公共部分
	public static void printCommonPart(Node head1, Node head2) {
		System.out.print("Common Part: ");
		while (head1 != null && head2 != null) {
			if (head1.value < head2.value) {
				head1 = head1.next;
			} else if (head1.value > head2.value) {
				head2 = head2.next;
			} else {
				System.out.print(head1.value + " ");
				head1 = head1.next;
				head2 = head2.next;
			}
		}
		System.out.println();
	}

	// 栈方式判断是否回文链表 O(n)空间
	public static boolean isPalindrome1(Node head) {
		Stack<Node> stack = new Stack<Node>();
		Node cur = head;
		while (cur != null) {
			stack.push(cur);
			cur = cur.next;
		}
		while (head != null) {
			if (head.value != stack.pop().value) {
				return false;
			}
			head = head.next;
		}
		return true;
	}

	// 快慢指针加栈 0(n/2)空间
	public static boolean isPalindrome2(Node head) {
		if (head == null || head.next == null) {
			return true;
		}
		Node right = head.next;
		Node cur = head;
		while (cur.next != null && cur.next.next != null) {
			right = right.next;
			cur = cur.next.next;
		}
		Stack<Node> stack = new Stack<Node>();
		while (right != null) {
			stack.push(right);
			right = right.next;
		}
		while (!stack.isEmpty()) {
			if (head.value != stack.pop().value) {
				return false;
			}
			head = head.next;
		}
		return true;
	}

	// 反转链表的方式 o(1)空间复杂度
	public static boolean isPalindrome3(Node head) {
		if (head == null || head.next == null) {
			return true;
		}
		Node n1 = head;
		Node n2 = head;
		while (n2.next != null && n2.next.next != null) { // find mid node
			n1 = n1.next; // n1 -> mid
			n2 = n2.next.next; // n2 -> end
		}
		n2 = n1.next; // n2 -> right part first node
		n1.next = null; // mid.next -> null
		Node n3 = null;
		while (n2 != null) { // right part convert
			n3 = n2.next; // n3 -> save next node
			n2.next = n1; // next of right node convert
			n1 = n2; // n1 move
			n2 = n3; // n2 move
		}
		n3 = n1; // n3 -> save last node
		n2 = head;// n2 -> left first node
		boolean res = true;
		while (n1 != null && n2 != null) { // check palindrome
			if (n1.value != n2.value) {
				res = false;
				break;
			}
			n1 = n1.next; // left to mid
			n2 = n2.next; // right to mid
		}
		n1 = n3.next;
		n3.next = null;
		while (n1 != null) { // recover list
			n2 = n1.next;
			n1.next = n3;
			n3 = n1;
			n1 = n2;
		}
		return res;
	}

	// 链表转为左小、中等、右大
	// 放入数组中快排在串成链表
	public static Node listPartition1(Node head, int pivot) {
		if (head == null) {
			return head;
		}
		Node cur = head;
		int i = 0;
		while (cur != null) {
			i++;
			cur = cur.next;
		}
		Node[] nodeArr = new Node[i];
		i = 0;
		cur = head;
		for (i = 0; i != nodeArr.length; i++) {
			nodeArr[i] = cur;
			cur = cur.next;
		}
		arrPartition(nodeArr, pivot);
		for (i = 1; i != nodeArr.length; i++) {
			nodeArr[i - 1].next = nodeArr[i];
		}
		nodeArr[i - 1].next = null;
		return nodeArr[0];
	}

	// 快排partition部分
	public static void arrPartition(Node[] nodeArr, int pivot) {
		int small = -1;
		int big = nodeArr.length;
		int index = 0;
		while (index != big) {
			if (nodeArr[index].value < pivot) {
				swap(nodeArr, ++small, index++);
			} else if (nodeArr[index].value == pivot) {
				index++;
			} else {
				swap(nodeArr, --big, index);
			}
		}
	}

	// 交换
	public static void swap(Node[] nodeArr, int a, int b) {
		Node tmp = nodeArr[a];
		nodeArr[a] = nodeArr[b];
		nodeArr[b] = tmp;
	}

	// 链表转为左小、中等、右大
	// O(N) O(1)
	public static Node listPartition2(Node head, int pivot) {
		Node sH = null; // small head
		Node sT = null; // small tail
		Node eH = null; // equal head
		Node eT = null; // equal tail
		Node bH = null; // big head
		Node bT = null; // big tail
		Node next = null; // save next node
		// every node distributed to three lists
		while (head != null) {
			next = head.next;
			head.next = null;
			if (head.value < pivot) {
				if (sH == null) {
					sH = head;
					sT = head;
				} else {
					sT.next = head;
					sT = head;
				}
			} else if (head.value == pivot) {
				if (eH == null) {
					eH = head;
					eT = head;
				} else {
					eT.next = head;
					eT = head;
				}
			} else {
				if (bH == null) {
					bH = head;
					bT = head;
				} else {
					bT.next = head;
					bT = head;
				}
			}
			head = next;
		}
		// small and equal reconnect
		if (sT != null) {
			sT.next = eH;
			eT = eT == null ? sT : eT;
		}
		// all reconnect
		if (eT != null) {
			eT.next = bH;
		}
		return sH != null ? sH : eH != null ? eH : bH;
	}

	// 随机链表的节点
	public static class RandomNode {
		public int value;
		public RandomNode next;
		public RandomNode rand;

		public RandomNode(int data) {
			this.value = data;
		}
	}

	// 散列表实现复制含有随机指针的链表
	public static RandomNode copyListWithRand1(RandomNode head) {
		HashMap<RandomNode, RandomNode> map = new HashMap<RandomNode, RandomNode>();
		RandomNode cur = head;
		while (cur != null) {
			map.put(cur, new RandomNode(cur.value));
			cur = cur.next;
		}
		cur = head;
		while (cur != null) {
			map.get(cur).next = map.get(cur.next);
			map.get(cur).rand = map.get(cur.rand);
			cur = cur.next;
		}
		return map.get(head);
	}

	// 两从遍历实现复制含有随机指针的链表
	public static RandomNode copyListWithRand2(RandomNode head) {
		if (head == null) {
			return null;
		}
		RandomNode cur = head;
		RandomNode next = null;
		// copy node and link to every node
		while (cur != null) {
			next = cur.next;
			cur.next = new RandomNode(cur.value);
			cur.next.next = next;
			cur = next;
		}
		cur = head;
		RandomNode curCopy = null;
		// set copy node rand
		while (cur != null) {
			next = cur.next.next;
			curCopy = cur.next;
			curCopy.rand = cur.rand != null ? cur.rand.next : null;
			cur = next;
		}
		RandomNode res = head.next;
		cur = head;
		// split
		while (cur != null) {
			next = cur.next.next;
			curCopy = cur.next;
			cur.next = next;
			curCopy.next = next != null ? next.next : null;
			cur = next;
		}
		return res;
	}

	// 散列表判断两链表交点
	public static Node getIntersectNode(Node head1, Node head2) {
		if (head1 == null || head2 == null) {
			return null;
		}
		Node loop1 = getLoopNode(head1);
		Node loop2 = getLoopNode(head2);
		if (loop1 == null && loop2 == null) {
			return noLoop(head1, head2);
		}
		if (loop1 != null && loop2 != null) {
			return bothLoop(head1, loop1, head2, loop2);
		}
		return null;
	}

	// 快慢指针判断两链表交点
	public static Node getLoopNode(Node head) {
		if (head == null || head.next == null || head.next.next == null) {
			return null;
		}
		Node n1 = head.next; // n1 -> slow
		Node n2 = head.next.next; // n2 -> fast
		while (n1 != n2) {
			if (n2.next == null || n2.next.next == null) {
				return null;
			}
			n2 = n2.next.next;
			n1 = n1.next;
		}
		n2 = head; // n2 -> walk again from head
		while (n1 != n2) {
			n1 = n1.next;
			n2 = n2.next;
		}
		return n1;
	}

	// 两无环链表相交的点
	public static Node noLoop(Node head1, Node head2) {
		if (head1 == null || head2 == null) {
			return null;
		}
		Node cur1 = head1;
		Node cur2 = head2;
		int n = 0;
		while (cur1.next != null) {
			n++;
			cur1 = cur1.next;
		}
		while (cur2.next != null) {
			n--;
			cur2 = cur2.next;
		}
		if (cur1 != cur2) {
			return null;
		}
		cur1 = n > 0 ? head1 : head2;
		cur2 = cur1 == head1 ? head2 : head1;
		n = Math.abs(n);
		while (n != 0) {
			n--;
			cur1 = cur1.next;
		}
		while (cur1 != cur2) {
			cur1 = cur1.next;
			cur2 = cur2.next;
		}
		return cur1;
	}

	// 两有环链表相交的点
	public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
		Node cur1 = null;
		Node cur2 = null;
		if (loop1 == loop2) {
			cur1 = head1;
			cur2 = head2;
			int n = 0;
			while (cur1 != loop1) {
				n++;
				cur1 = cur1.next;
			}
			while (cur2 != loop2) {
				n--;
				cur2 = cur2.next;
			}
			cur1 = n > 0 ? head1 : head2;
			cur2 = cur1 == head1 ? head2 : head1;
			n = Math.abs(n);
			while (n != 0) {
				n--;
				cur1 = cur1.next;
			}
			while (cur1 != cur2) {
				cur1 = cur1.next;
				cur2 = cur2.next;
			}
			return cur1;
		} else {
			cur1 = loop1.next;
			while (cur1 != loop1) {
				if (cur1 == loop2) {
					return loop1;
				}
				cur1 = cur1.next;
			}
			return null;
		}
	}

	// ---------------------------------------------------------rm4终-----------------------------------------------------

	// ---------------------------------------------------------rm5始-----------------------------------------------------

	// 二叉树节点
	public static class BinNode {
		public int value;
		public BinNode left;
		public BinNode right;

		public BinNode(int data) {
			this.value = data;
		}
	}

	// 先序遍历
	public static void preOrderRecur(BinNode head) {
		if (head == null) {
			return;
		}
		System.out.print(head.value + " ");
		preOrderRecur(head.left);
		preOrderRecur(head.right);
	}

	// 中序遍历
	public static void inOrderRecur(BinNode head) {
		if (head == null) {
			return;
		}
		inOrderRecur(head.left);
		System.out.print(head.value + " ");
		inOrderRecur(head.right);
	}

	// 后序遍历
	public static void posOrderRecur(BinNode head) {
		if (head == null) {
			return;
		}
		posOrderRecur(head.left);
		posOrderRecur(head.right);
		System.out.print(head.value + " ");
	}

	// 先序 栈
	public static void preOrderUnRecur(BinNode head) {
		System.out.print("pre-order: ");
		if (head != null) {
			Stack<BinNode> stack = new Stack<BinNode>();
			stack.add(head);
			while (!stack.isEmpty()) {
				head = stack.pop();
				System.out.print(head.value + " ");
				if (head.right != null) {
					stack.push(head.right);
				}
				if (head.left != null) {
					stack.push(head.left);
				}
			}
		}
		System.out.println();
	}

	// 中序 栈
	public static void inOrderUnRecur(BinNode head) {
		System.out.print("in-order: ");
		if (head != null) {
			Stack<BinNode> stack = new Stack<BinNode>();
			while (!stack.isEmpty() || head != null) {
				if (head != null) {
					stack.push(head);
					head = head.left;
				} else {
					head = stack.pop();
					System.out.print(head.value + " ");
					head = head.right;
				}
			}
		}
		System.out.println();
	}

	// 后序 双栈
	public static void posOrderUnRecur1(BinNode head) {
		System.out.print("pos-order: ");
		if (head != null) {
			Stack<BinNode> s1 = new Stack<BinNode>();
			Stack<BinNode> s2 = new Stack<BinNode>();
			s1.push(head);
			while (!s1.isEmpty()) {
				head = s1.pop();
				s2.push(head);
				if (head.left != null) {
					s1.push(head.left);
				}
				if (head.right != null) {
					s1.push(head.right);
				}
			}
			while (!s2.isEmpty()) {
				System.out.print(s2.pop().value + " ");
			}
		}
		System.out.println();
	}

	// 后序 栈
	public static void posOrderUnRecur2(BinNode h) {
		System.out.print("pos-order: ");
		if (h != null) {
			Stack<BinNode> stack = new Stack<BinNode>();
			stack.push(h);
			BinNode c = null;
			while (!stack.isEmpty()) {
				c = stack.peek();
				if (c.left != null && h != c.left && h != c.right) {
					stack.push(c.left);
				} else if (c.right != null && h != c.right) {
					stack.push(c.right);
				} else {
					System.out.print(stack.pop().value + " ");
					h = c;
				}
			}
		}
		System.out.println();
	}

	// 二叉树最大宽度
	public static int getMaxWidth(BinNode head) {
		if (head == null) {
			return 0;
		}
		int maxWidth = 0;
		int curWidth = 0;
		int curLevel = 0;
		HashMap<BinNode, Integer> levelMap = new HashMap<>();
		levelMap.put(head, 1);
		LinkedList<BinNode> queue = new LinkedList<>();
		queue.add(head);
		BinNode node = null;
		BinNode left = null;
		BinNode right = null;
		while (!queue.isEmpty()) {
			node = queue.poll();
			left = node.left;
			right = node.right;
			if (left != null) {
				levelMap.put(left, levelMap.get(node) + 1);
				queue.add(left);
			}
			if (right != null) {
				levelMap.put(right, levelMap.get(node) + 1);
				queue.add(right);
			}
			if (levelMap.get(node) > curLevel) {
				curWidth = 0;
				curLevel = levelMap.get(node);
			} else {
				curWidth++;
			}
			maxWidth = Math.max(maxWidth, curWidth);
		}
		return maxWidth;
	}

	// 二叉搜索树
	public static boolean isBST(BinNode head) {
		if (head == null) {
			return true;
		}
		LinkedList<BinNode> inOrderList = new LinkedList<>();
		process(head, inOrderList);
		int pre = Integer.MIN_VALUE;
		for (BinNode cur : inOrderList) {
			if (pre >= cur.value) {
				return false;
			}
			pre = cur.value;
		}
		return true;
	}

	public static void process(BinNode node, LinkedList<BinNode> inOrderList) {
		if (node == null) {
			return;
		}
		process(node.left, inOrderList);
		inOrderList.add(node);
		process(node.right, inOrderList);
	}

	// 判断完全二叉树
	public static boolean isCBT(BinNode head) {
		if (head == null) {
			return true;
		}
		LinkedList<BinNode> queue = new LinkedList<>();
		boolean leaf = false;
		BinNode l = null;
		BinNode r = null;
		queue.add(head);
		while (!queue.isEmpty()) {
			head = queue.poll();
			l = head.left;
			r = head.right;
			if ((leaf && (l != null || r != null)) || (l == null && r != null)) {
				return false;
			}
			if (l != null) {
				queue.add(l);
			}
			if (r != null) {
				queue.add(r);
			} else {
				leaf = true;
			}
		}
		return true;
	}

	// 判断平衡二叉树
	public static boolean isBalanced(BinNode head) {
		return process(head).isBalanced;
	}

	public static class ReturnType {
		public boolean isBalanced;
		public int height;

		public ReturnType(boolean isB, int hei) {
			isBalanced = isB;
			height = hei;
		}
	}

	public static ReturnType process(BinNode x) {
		if (x == null) {
			return new ReturnType(true, 0);
		}
		ReturnType leftData = process(x.left);
		ReturnType rightData = process(x.right);
		int height = Math.max(leftData.height, rightData.height);
		boolean isBalanced = leftData.isBalanced && rightData.isBalanced
				&& Math.abs(leftData.height - rightData.height) < 2;
		return new ReturnType(isBalanced, height);
	}

	// 最近公共父节点
	public static BinNode lowestAncestor(BinNode head, BinNode o1, BinNode o2) {
		if (head == null || head == o1 || head == o2) {
			return head;
		}
		BinNode left = lowestAncestor(head.left, o1, o2);
		BinNode right = lowestAncestor(head.right, o1, o2);
		if (left != null && right != null) {
			return head;
		}
		return left != null ? left : right;
	}

	// map最近公共父节点
	public static class Record1 {
		private HashMap<BinNode, BinNode> map;

		public Record1(BinNode head) {
			map = new HashMap<BinNode, BinNode>();
			if (head != null) {
				map.put(head, null);
			}
			setMap(head);
		}

		private void setMap(BinNode head) {
			if (head == null) {
				return;
			}
			if (head.left != null) {
				map.put(head.left, head);
			}
			if (head.right != null) {
				map.put(head.right, head);
			}
			setMap(head.left);
			setMap(head.right);
		}

		public BinNode query(BinNode o1, BinNode o2) {
			HashSet<BinNode> path = new HashSet<BinNode>();
			while (map.containsKey(o1)) {
				path.add(o1);
				o1 = map.get(o1);
			}
			while (!path.contains(o2)) {
				o2 = map.get(o2);
			}
			return o2;
		}
	}

	// map最近公共父节点
	public static class Record2 {
		private HashMap<BinNode, HashMap<BinNode, BinNode>> map;

		public Record2(BinNode head) {
			map = new HashMap<BinNode, HashMap<BinNode, BinNode>>();
			initMap(head);
			setMap(head);
		}

		private void initMap(BinNode head) {
			if (head == null) {
				return;
			}
			map.put(head, new HashMap<BinNode, BinNode>());
			initMap(head.left);
			initMap(head.right);
		}

		private void setMap(BinNode head) {
			if (head == null) {
				return;
			}
			headRecord(head.left, head);
			headRecord(head.right, head);
			subRecord(head);
			setMap(head.left);
			setMap(head.right);
		}

		private void headRecord(BinNode n, BinNode h) {
			if (n == null) {
				return;
			}
			map.get(n).put(h, h);
			headRecord(n.left, h);
			headRecord(n.right, h);
		}

		private void subRecord(BinNode head) {
			if (head == null) {
				return;
			}
			preLeft(head.left, head.right, head);
			subRecord(head.left);
			subRecord(head.right);
		}

		private void preLeft(BinNode l, BinNode r, BinNode h) {
			if (l == null) {
				return;
			}
			preRight(l, r, h);
			preLeft(l.left, r, h);
			preLeft(l.right, r, h);
		}

		private void preRight(BinNode l, BinNode r, BinNode h) {
			if (r == null) {
				return;
			}
			map.get(l).put(r, h);
			preRight(l, r.left, h);
			preRight(l, r.right, h);
		}

		public BinNode query(BinNode o1, BinNode o2) {
			if (o1 == o2) {
				return o1;
			}
			if (map.containsKey(o1)) {
				return map.get(o1).get(o2);
			}
			if (map.containsKey(o2)) {
				return map.get(o2).get(o1);
			}
			return null;
		}
	}

	public static class PNode {
		public int value;
		public PNode left;
		public PNode right;
		public PNode parent;

		public PNode(int data) {
			this.value = data;
		}
	}

	// 中序的后继节点
	public static PNode getSuccessorNode(PNode node) {
		if (node == null) {
			return node;
		}
		if (node.right != null) {
			return getLeftMost(node.right);
		} else {
			PNode parent = node.parent;
			while (parent != null && parent.left != node) {
				node = parent;
				parent = node.parent;
			}
			return parent;
		}
	}

	public static PNode getLeftMost(PNode node) {
		if (node == null) {
			return node;
		}
		while (node.left != null) {
			node = node.left;
		}
		return node;
	}

	// 先序序列化
	public static String serialByPre(BinNode head) {
		if (head == null) {
			return "#!";
		}
		String res = head.value + "!";
		res += serialByPre(head.left);
		res += serialByPre(head.right);
		return res;
	}

	// 先序反序列化
	public static BinNode reconByPreString(String preStr) {
		String[] values = preStr.split("!");
		Queue<String> queue = new LinkedList<String>();
		for (int i = 0; i != values.length; i++) {
			queue.offer(values[i]);
		}
		return reconPreOrder(queue);
	}

	public static BinNode reconPreOrder(Queue<String> queue) {
		String value = queue.poll();
		if (value.equals("#")) {
			return null;
		}
		BinNode head = new BinNode(Integer.valueOf(value));
		head.left = reconPreOrder(queue);
		head.right = reconPreOrder(queue);
		return head;
	}

	// 层级序列化
	public static String serialByLevel(BinNode head) {
		if (head == null) {
			return "#!";
		}
		String res = head.value + "!";
		Queue<BinNode> queue = new LinkedList<BinNode>();
		queue.offer(head);
		while (!queue.isEmpty()) {
			head = queue.poll();
			if (head.left != null) {
				res += head.left.value + "!";
				queue.offer(head.left);
			} else {
				res += "#!";
			}
			if (head.right != null) {
				res += head.right.value + "!";
				queue.offer(head.right);
			} else {
				res += "#!";
			}
		}
		return res;
	}

	// 层级反序列化
	public static BinNode reconByLevelString(String levelStr) {
		String[] values = levelStr.split("!");
		int index = 0;
		BinNode head = generateBinNodeByString(values[index++]);
		Queue<BinNode> queue = new LinkedList<BinNode>();
		if (head != null) {
			queue.offer(head);
		}
		BinNode BinNode = null;
		while (!queue.isEmpty()) {
			BinNode = queue.poll();
			BinNode.left = generateBinNodeByString(values[index++]);
			BinNode.right = generateBinNodeByString(values[index++]);
			if (BinNode.left != null) {
				queue.offer(BinNode.left);
			}
			if (BinNode.right != null) {
				queue.offer(BinNode.right);
			}
		}
		return head;
	}

	public static BinNode generateBinNodeByString(String val) {
		if (val.equals("#")) {
			return null;
		}
		return new BinNode(Integer.valueOf(val));
	}

	// 纸条折痕
	// int N = 1;
	// printAllFolds(N);
	public static void printAllFolds(int N) {
		printProcess(1, N, true);
	}

	public static void printProcess(int i, int N, boolean down) {
		if (i > N) {
			return;
		}
		printProcess(i + 1, N, true);
		System.out.println(down ? "down " : "up ");
		printProcess(i + 1, N, false);
	}

	// ---------------------------------------------------------rm5终-----------------------------------------------------

	// ---------------------------------------------------------rm6始-----------------------------------------------------

	// 图的点
	static class TNode {
		public int value;
		public int in;
		public int out;
		public ArrayList<TNode> nexts;
		public ArrayList<Edge> edges;

		public TNode(int value) {
			this.value = value;
			in = 0;
			out = 0;
			nexts = new ArrayList<>();
			edges = new ArrayList<>();
		}
	}

	// 图的边
	static class Edge {
		public int weight;
		public TNode from;
		public TNode to;

		public Edge(int weight, TNode from, TNode to) {
			this.weight = weight;
			this.from = from;
			this.to = to;
		}
	}

	// 构图
	static class Graph {
		public HashMap<Integer, TNode> nodes;
		public HashSet<Edge> edges;

		public Graph() {
			nodes = new HashMap<>();
			edges = new HashSet<>();
		}
	}

	// 矩阵构图
	public static Graph createGraph(Integer[][] matrix) {
		Graph graph = new Graph();
		for (int i = 0; i < matrix.length; i++) {
			Integer weight = matrix[i][0];
			Integer from = matrix[i][1];
			Integer to = matrix[i][2];
			if (!graph.nodes.containsKey(from)) {
				graph.nodes.put(from, new TNode(from));
			}
			if (!graph.nodes.containsKey(to)) {
				graph.nodes.put(to, new TNode(to));
			}
			TNode fromNode = graph.nodes.get(from);
			TNode toNode = graph.nodes.get(to);
			Edge newEdge = new Edge(weight, fromNode, toNode);
			fromNode.nexts.add(toNode);
			fromNode.out++;
			toNode.in++;
			fromNode.edges.add(newEdge);
			graph.edges.add(newEdge);
		}
		return graph;
	}

	// 广度优先遍历
	public static void bfs(TNode node) {
		if (node == null) {
			return;
		}
		// 队列
		Queue<TNode> queue = new LinkedList<>();
		// 记录set
		HashSet<TNode> map = new HashSet<>();
		// 队列和记录set先存入首node
		queue.add(node);
		map.add(node);
		// 队列不为空
		while (!queue.isEmpty()) {
			// 出队 打印
			TNode cur = queue.poll();
			System.out.println(cur.value);
			// 遍历节点next不在记录中即入队入记录
			for (TNode next : cur.nexts) {
				if (!map.contains(next)) {
					map.add(next);
					queue.add(next);
				}
			}
		}
	}

	// 深度优先遍历
	public static void dfs(TNode node) {
		if (node == null) {
			return;
		}
		// 栈
		Stack<TNode> stack = new Stack<>();
		// 记录set
		HashSet<TNode> set = new HashSet<>();
		// 入栈 入记录
		stack.add(node);
		set.add(node);
		// 入栈即打印
		System.out.println(node.value);
		// 栈不为空
		while (!stack.isEmpty()) {
			// 出栈
			TNode cur = stack.pop();
			// 遍历next 满足一个即结束
			for (TNode next : cur.nexts) {
				// 不在记录中 cur再次入栈 next入栈 打印 break
				if (!set.contains(next)) {
					stack.push(cur);
					stack.push(next);
					set.add(next);
					System.out.println(next.value);
					break;
				}
			}
		}
	}

	// 拓扑排序
	public static List<TNode> sortedTopology(Graph graph) {
		// key：某一node
		// value:剩余的入度
		HashMap<TNode, Integer> inMap = new HashMap<>();
		// 入度为0的点，才能进这个队列
		Queue<TNode> zeroInQueue = new LinkedList<>();
		// 首先找到初始入度为0的点
		for (TNode node : graph.nodes.values()) {
			inMap.put(node, node.in);
			if (node.in == 0) {
				zeroInQueue.add(node);
			}
		}
		// 结果集合
		List<TNode> result = new ArrayList<>();
		// 队列不为空
		while (!zeroInQueue.isEmpty()) {
			// 出队 加入结果集
			TNode cur = zeroInQueue.poll();
			result.add(cur);
			// 依次找，依次消除影响，入度为0添加
			for (TNode next : cur.nexts) {
				inMap.put(next, inMap.get(next) - 1);
				if (inMap.get(next) == 0) {
					zeroInQueue.add(next);
				}
			}
		}
		return result;
	}

	// 比较器
	public static class EdgeComparator implements Comparator<Edge> {

		@Override
		public int compare(Edge o1, Edge o2) {
			return o1.weight - o2.weight;
		}
	}

	// 最小生成树-普里姆算法 O(V * logE)
	public static Set<Edge> primMST(Graph graph) {
		PriorityQueue<Edge> pQueue = 
				new PriorityQueue<>((o1, o2) -> (o1.weight - o2.weight));// 有序集合的边
		HashSet<TNode> exist = new HashSet<>();// 记录已有的点
		HashSet<Edge> result = new HashSet<>();// 结果边

		// 随便挑一个  
		for (TNode node : graph.nodes.values()) {
			// 可能只执行一次
			if (!exist.contains(node)) {

				// 入记录集合，将此点的所有边加入到有序集合中
				exist.add(node);
				for (Edge edge : node.edges)
					pQueue.add(edge);

				// 从有序集合中找最小的边，并将对应的toNode加入，并将toNode的所有边加入有序集合中
				// 可能循环执行到结束
				while (!pQueue.isEmpty()) {
					Edge edge = pQueue.poll();
					TNode toNode = edge.to;
					if (!exist.contains(toNode)) {// 是新点才操作
						exist.add(toNode);
						result.add(edge);
						// 将新点的边入有序队列
						for (Edge nextEdge : toNode.edges)
							pQueue.add(nextEdge);
					}
				}
			}
			
			// break; 不break防止森林的情况
		}
		return result;
	}

	
	// 请保证graph是连通图
	// graph[i][j]表示点i到点j的距离，如果是系统最大值代表无路
	// 返回值是最小连通图的路径之和
	public static int prim(int[][] graph) {

		int size = graph.length;
		int[] distances = new int[size];
		// 标记点是否有取过
		boolean[] visit = new boolean[size];
		visit[0] = true;
		// 先去第一行数据，即第一个点到所有点距离
		for (int i = 0; i < size; i++) {
			distances[i] = graph[0][i];
		}
		int sum = 0;
		for (int i = 1; i < size; i++) {
			// 首次是从第一个到所有点的距离，取出最小的边minPath，相应的坐标即对应的点minIndex
			// 后续是更新的最小边的数组
			int minPath = Integer.MAX_VALUE;
			int minIndex = -1;
			for (int j = 0; j < size; j++) {
				if (!visit[j] && distances[j] < minPath) {
					minPath = distances[j];
					minIndex = j;
				}
			}
			if (minIndex == -1) {
				return sum;
			}
			visit[minIndex] = true;
			sum += minPath;

			// 根据新的点 更新边数组
			for (int j = 0; j < size; j++) {
				if (!visit[j] && distances[j] > graph[minIndex][j]) {
					distances[j] = graph[minIndex][j];
				}
			}
		}
		return sum;
	}
	
	// 并查集
		public static class UnionFind {
			private HashMap<TNode, TNode> fatherMap;
			private HashMap<TNode, Integer> rankMap;

			public UnionFind() {
				fatherMap = new HashMap<TNode, TNode>();
				rankMap = new HashMap<TNode, Integer>();
			}
			// 利用递归取代栈实现查找最终父节点和将路径上节点指向最终父节点
			private TNode findFather(TNode n) {
				TNode father = fatherMap.get(n);
				if (father != n) {
					father = findFather(father);
				}
				fatherMap.put(n, father);
				return father;
			}
			// 重新初始化并查集
			public void makeSets(Collection<TNode> nodes) {
				fatherMap.clear();
				rankMap.clear();
				for (TNode node : nodes) {
					fatherMap.put(node, node);
					rankMap.put(node, 1);
				}
			}
			// 查看是否是同一个集合
			public boolean isSameSet(TNode a, TNode b) {
				return findFather(a) == findFather(b);
			}
			
			// 合并两个集合
			public void union(TNode a, TNode b) {
				if (a == null || b == null) {
					return;
				}
				TNode aFather = findFather(a);
				TNode bFather = findFather(b);
				if (aFather != bFather) {
					int aFrank = rankMap.get(aFather);
					int bFrank = rankMap.get(bFather);
					if (aFrank <= bFrank) {
						fatherMap.put(aFather, bFather);
						rankMap.put(bFather, aFrank + bFrank);
					} else {
						fatherMap.put(bFather, aFather);
						rankMap.put(aFather, aFrank + bFrank);
					}
				}
			}
		}

	// 最小生成树-克鲁斯卡尔算法（并查集用来判断是否连通）
	public static Set<Edge> kruskalMST(Graph graph) {
		UnionFind unionFind = new UnionFind();
		// 建立每个点为集合的并查集
		unionFind.makeSets(graph.nodes.values());
		// 将所有边入优先级队列
		PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());
		for (Edge edge : graph.edges) {
			priorityQueue.add(edge);
		}
		// 结果集
		Set<Edge> result = new HashSet<>();
		while (!priorityQueue.isEmpty()) {
			// 每次出一个最小的边
			Edge edge = priorityQueue.poll();
			// 如果该边的两端点不是同一并查集，边入结果集，两点的集合合并
			if (!unionFind.isSameSet(edge.from, edge.to)) {
				result.add(edge);
				unionFind.union(edge.from, edge.to);
			}
		}
		return result;
	}

	

	// 最短路径-迪杰斯特拉算法
	public static HashMap<TNode, Integer> dijkstra1(TNode head) {
		// 从head出发到所有点的最小距离
		// key：从head出发到达key
		// value：从head出发到达key的最小距离
		// 如果在表中，没有T的记录，含义是从head出发到T这个点的距离为正无穷
		HashMap<TNode, Integer> distanceMap = new HashMap<>();
		// 到自己为0
		distanceMap.put(head, 0);
		// 已经求过距离的节点
		HashSet<TNode> selectedNodes = new HashSet<>();
		// 在未选择的节点中选一个距离最小的节点
		TNode minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
		while (minNode != null) {
			// 求当前距离
			int distance = distanceMap.get(minNode);
			// 遍历他的边
			for (Edge edge : minNode.edges) {
				// 拿出to的点
				TNode toNode = edge.to;
				// 不再map中则加入
				if (!distanceMap.containsKey(toNode)) {
					// 加上distance代表到head的距离
					distanceMap.put(toNode, distance + edge.weight);
				}
				// 在则比较当前到head的距离和新生成的距离谁小
				distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));
			}
			// 放入set中不再操作
			selectedNodes.add(minNode);
			// 选择新的最小点
			minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
		}
		return distanceMap;
	}

	// 查map中距离最小的节点且不再已选择的set里
	public static TNode getMinDistanceAndUnselectedNode(HashMap<TNode, Integer> distanceMap,
			HashSet<TNode> touchedNodes) {
		TNode minNode = null;
		int minDistance = Integer.MAX_VALUE;
		// 遍历map
		for (Entry<TNode, Integer> entry : distanceMap.entrySet()) {
			TNode node = entry.getKey();
			int distance = entry.getValue();
			// 当前点不在set中且距离更小则更新minNode
			if (!touchedNodes.contains(node) && distance < minDistance) {
				minNode = node;
				minDistance = distance;
			}
		}
		return minNode;
	}

	public static class NodeRecord {
		public TNode node;
		public int distance;

		public NodeRecord(TNode node, int distance) {
			this.node = node;
			this.distance = distance;
		}
	}

	public static class NodeHeap {
		private TNode[] nodes;
		private HashMap<TNode, Integer> heapIndexMap;
		private HashMap<TNode, Integer> distanceMap;
		private int size;

		public NodeHeap(int size) {
			nodes = new TNode[size];
			heapIndexMap = new HashMap<>();
			distanceMap = new HashMap<>();
			this.size = 0;
		}

		public boolean isEmpty() {
			return size == 0;
		}

		public void addOrUpdateOrIgnore(TNode node, int distance) {
			if (inHeap(node)) {
				distanceMap.put(node, Math.min(distanceMap.get(node), distance));
				insertHeapify(node, heapIndexMap.get(node));
			}
			if (!isEntered(node)) {
				nodes[size] = node;
				heapIndexMap.put(node, size);
				distanceMap.put(node, distance);
				insertHeapify(node, size++);
			}
		}

		public NodeRecord pop() {
			NodeRecord nodeRecord = new NodeRecord(nodes[0], distanceMap.get(nodes[0]));
			swap(0, size - 1);
			heapIndexMap.put(nodes[size - 1], -1);
			distanceMap.remove(nodes[size - 1]);
			nodes[size - 1] = null;
			heapify(0, --size);
			return nodeRecord;
		}

		private void insertHeapify(TNode node, int index) {
			while (distanceMap.get(nodes[index]) < distanceMap.get(nodes[(index - 1) / 2])) {
				swap(index, (index - 1) / 2);
				index = (index - 1) / 2;
			}
		}

		private void heapify(int index, int size) {
			int left = index * 2 + 1;
			while (left < size) {
				int smallest = left + 1 < size && distanceMap.get(nodes[left + 1]) < distanceMap.get(nodes[left])
						? left + 1
						: left;
				smallest = distanceMap.get(nodes[smallest]) < distanceMap.get(nodes[index]) ? smallest : index;
				if (smallest == index) {
					break;
				}
				swap(smallest, index);
				index = smallest;
				left = index * 2 + 1;
			}
		}

		private boolean isEntered(TNode node) {
			return heapIndexMap.containsKey(node);
		}

		private boolean inHeap(TNode node) {
			return isEntered(node) && heapIndexMap.get(node) != -1;
		}

		private void swap(int index1, int index2) {
			heapIndexMap.put(nodes[index1], index2);
			heapIndexMap.put(nodes[index2], index1);
			TNode tmp = nodes[index1];
			nodes[index1] = nodes[index2];
			nodes[index2] = tmp;
		}
	}

	// 最短路径-迪杰斯特拉算法
	public static HashMap<TNode, Integer> dijkstra2(TNode head, int size) {
		NodeHeap nodeHeap = new NodeHeap(size);
		nodeHeap.addOrUpdateOrIgnore(head, 0);
		HashMap<TNode, Integer> result = new HashMap<>();
		while (!nodeHeap.isEmpty()) {
			NodeRecord record = nodeHeap.pop();
			TNode cur = record.node;
			int distance = record.distance;
			for (Edge edge : cur.edges) {
				nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);
			}
			result.put(cur, distance);
		}
		return result;
	}

	public static class TrieNode {
		public int path;
		public int end;
		public TrieNode[] nexts;

		public TrieNode() {
			path = 0;
			end = 0;
			nexts = new TrieNode[26];
		}
	}

	// 前缀树
	public static class Trie {
		private TrieNode root;

		public Trie() {
			root = new TrieNode();
		}

		public void insert(String word) {
			if (word == null) {
				return;
			}
			char[] chs = word.toCharArray();
			TrieNode node = root;
			int index = 0;
			for (int i = 0; i < chs.length; i++) {
				index = chs[i] - 'a';
				if (node.nexts[index] == null) {
					node.nexts[index] = new TrieNode();
				}
				node = node.nexts[index];
				node.path++;
			}
			node.end++;
		}

		public void delete(String word) {
			if (search(word) != 0) {
				char[] chs = word.toCharArray();
				TrieNode node = root;
				int index = 0;
				for (int i = 0; i < chs.length; i++) {
					index = chs[i] - 'a';
					if (--node.nexts[index].path == 0) {
						node.nexts[index] = null;
						return;
					}
					node = node.nexts[index];
				}
				node.end--;
			}
		}

		public int search(String word) {
			if (word == null) {
				return 0;
			}
			char[] chs = word.toCharArray();
			TrieNode node = root;
			int index = 0;
			for (int i = 0; i < chs.length; i++) {
				index = chs[i] - 'a';
				if (node.nexts[index] == null) {
					return 0;
				}
				node = node.nexts[index];
			}
			return node.end;
		}

		public int prefixNumber(String pre) {
			if (pre == null) {
				return 0;
			}
			char[] chs = pre.toCharArray();
			TrieNode node = root;
			int index = 0;
			for (int i = 0; i < chs.length; i++) {
				index = chs[i] - 'a';
				if (node.nexts[index] == null) {
					return 0;
				}
				node = node.nexts[index];
			}
			return node.path;
		}
	}

	// ---------------------------------------------------------rm6终-----------------------------------------------------

	// ---------------------------------------------------------rm7始-----------------------------------------------------

	// 字符串字典序
	public static class MyComparator implements Comparator<String> {
		@Override
		public int compare(String a, String b) {
			return (a + b).compareTo(b + a);
		}
	}

	// 字典序
	public static String lowestString(String[] strs) {
		if (strs == null || strs.length == 0) {
			return "";
		}
		Arrays.sort(strs, new MyComparator());
		String res = "";
		for (int i = 0; i < strs.length; i++) {
			res += strs[i];
		}
		return res;
	}

	// 切金条
	public static int lessMoney(int[] arr) {
		PriorityQueue<Integer> pQ = new PriorityQueue<>();
		for (int i = 0; i < arr.length; i++) {
			pQ.add(arr[i]);
		}
		int sum = 0;
		int cur = 0;
		while (pQ.size() > 1) {
			cur = pQ.poll() + pQ.poll();
			sum += cur;
			pQ.add(cur);
		}
		return sum;
	}

	public static class MinheapComparator implements Comparator<Integer> {

		@Override
		public int compare(Integer o1, Integer o2) {
			return o1 - o2; // < 0 o1 < o2 负数
		}
	}

	public static class MaxheapComparator implements Comparator<Integer> {

		@Override
		public int compare(Integer o1, Integer o2) {
			return o2 - o1; // < o2 < o1
		}
	}

	public static class Program {
		public int start;
		public int end;

		public Program(int start, int end) {
			this.start = start;
			this.end = end;
		}
	}

	public static class ProgramComparator implements Comparator<Program> {

		@Override
		public int compare(Program o1, Program o2) {
			return o1.end - o2.end;
		}

	}

	// 会议安排
	public static int bestArrange(Program[] programs, int start) {
		Arrays.sort(programs, new ProgramComparator());
		int result = 0;
		for (int i = 0; i < programs.length; i++) {
			if (start <= programs[i].start) {
				result++;
				start = programs[i].end;
			}
		}
		return result;
	}

	public static class XNode {
		public int p;
		public int c;

		public XNode(int p, int c) {
			this.p = p;
			this.c = c;
		}
	}

	public static class MinCostComparator implements Comparator<XNode> {

		@Override
		public int compare(XNode o1, XNode o2) {
			return o1.c - o2.c;
		}
	}

	public static class MaxProfitComparator implements Comparator<XNode> {

		@Override
		public int compare(XNode o1, XNode o2) {
			return o2.p - o1.p;
		}
	}

	// 项目利润
	public static int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {
		XNode[] nodes = new XNode[Profits.length];
		for (int i = 0; i < Profits.length; i++) {
			nodes[i] = new XNode(Profits[i], Capital[i]);
		}

		PriorityQueue<XNode> minCostQ = new PriorityQueue<>(new MinCostComparator());
		PriorityQueue<XNode> maxProfitQ = new PriorityQueue<>(new MaxProfitComparator());
		for (int i = 0; i < nodes.length; i++) {
			minCostQ.add(nodes[i]);
		}
		for (int i = 0; i < k; i++) {
			while (!minCostQ.isEmpty() && minCostQ.peek().c <= W) {
				maxProfitQ.add(minCostQ.poll());
			}
			if (maxProfitQ.isEmpty()) {
				return W;
			}
			W += maxProfitQ.poll().p;
		}
		return W;
	}

	// 数据流的中位数
	public static class MedianHolder {
		private PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(new MaxHeapComparator());
		private PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>(new MinHeapComparator());

		private void modifyTwoHeapsSize() {
			if (this.maxHeap.size() == this.minHeap.size() + 2) {
				this.minHeap.add(this.maxHeap.poll());
			}
			if (this.minHeap.size() == this.maxHeap.size() + 2) {
				this.maxHeap.add(this.minHeap.poll());
			}
		}

		public void addNumber(int num) {
			if (maxHeap.isEmpty() || num <= maxHeap.peek()) {
				maxHeap.add(num);
			} else {
				minHeap.add(num);
			}
			modifyTwoHeapsSize();
		}

		public Integer getMedian() {
			int maxHeapSize = this.maxHeap.size();
			int minHeapSize = this.minHeap.size();
			if (maxHeapSize + minHeapSize == 0) {
				return null;
			}
			Integer maxHeapHead = this.maxHeap.peek();
			Integer minHeapHead = this.minHeap.peek();
			if (((maxHeapSize + minHeapSize) & 1) == 0) {
				return (maxHeapHead + minHeapHead) / 2;
			}
			return maxHeapSize > minHeapSize ? maxHeapHead : minHeapHead;
		}

	}

	public static class MaxHeapComparator implements Comparator<Integer> {
		@Override
		public int compare(Integer o1, Integer o2) {
			if (o2 > o1) {
				return 1;
			} else {
				return -1;
			}
		}
	}

	public static class MinHeapComparator implements Comparator<Integer> {
		@Override
		public int compare(Integer o1, Integer o2) {
			if (o2 < o1) {
				return 1;
			} else {
				return -1;
			}
		}
	}

	// ---------------------------------------------------------rm7终-----------------------------------------------------
	// ---------------------------------------------------------rm8始-----------------------------------------------------

	// 汉若塔
	public static void hanoi(int n) {
		if (n > 0) {
			func(n, n, "left", "mid", "right");
		}
	}

	// 1 ~ n-1 左->中
	// n 左->右
	// 1 ~ n-1 中->右
	public static void func(int rest, int down, String from, String help, String to) {
		if (rest == 1) {
			System.out.println("move " + down + " from " + from + " to " + to);
		} else {
			func(rest - 1, down - 1, from, to, help);
			func(1, down, from, help, to);
			func(rest - 1, down - 1, help, from, to);
		}
	}

	// 原地数组求子序列
	public static void printAllSubsquence(String str) {
		char[] chs = str.toCharArray();
		process(chs, 0);
	}

	public static void process(char[] chs, int i) {
		if (i == chs.length) {
			System.out.println(String.valueOf(chs));
			return;
		}
		process(chs, i + 1);

		char tmp = chs[i];
		chs[i] = 0;
		process(chs, i + 1);
		chs[i] = tmp;
	}

	// 列表求子序列
	public static void function(String str) {
		char[] chs = str.toCharArray();
		process(chs, 0, new ArrayList<Character>());
	}

	public static void process(char[] chs, int i, List<Character> res) {
		if (i == chs.length) {
			System.out.println(res);
			return;
		}

		List<Character> resKeep = new ArrayList<>(res);
		resKeep.add(chs[i]);
		process(chs, i + 1, resKeep);

		List<Character> resNoInclude = new ArrayList<>(res);
		process(chs, i + 1, resNoInclude);
	}

	// 字符串子序列
	static void process(char[] str, int index, List<String> ans, String path) {
		if (index == str.length) {
			ans.add(path);
			return;
		}

		String noPath = path;
		process(str, index + 1, ans, noPath);

		String yesPath = path + String.valueOf(str[index]);
		process(str, index + 1, ans, yesPath);
	}

	// 反转
	public static void reverse(Stack<Integer> stack) {
		if (stack.isEmpty()) {
			return;
		}
		int i = getAndRemoveLastElement(stack);
		reverse(stack);
		stack.push(i);
	}

	// 逆序一个栈，不申请额外空间，用递归
	public static int getAndRemoveLastElement(Stack<Integer> stack) {
		int result = stack.pop();
		if (stack.isEmpty()) {
			return result;
		} else {
			int last = getAndRemoveLastElement(stack);
			stack.push(result);
			return last;
		}
	}

	public static int number(String str) {
		if (str == null || str.length() == 0) {
			return 0;
		}
		return process1(str.toCharArray(), 0);
	}

	// 数字转字符串 1-A 2-B 3-C... 111-AAA、KA、AK
	public static int process1(char[] chs, int i) {
		if (i == chs.length) {
			return 1;
		}
		if (chs[i] == '0') {
			return 0;
		}
		if (chs[i] == '1') {
			int res = process1(chs, i + 1);
			if (i + 1 < chs.length) {
				res += process1(chs, i + 2);
			}
			return res;
		}
		if (chs[i] == '2') {
			int res = process1(chs, i + 1);
			if (i + 1 < chs.length && (chs[i + 1] >= '0' && chs[i + 1] <= '6')) {
				res += process1(chs, i + 2);
			}
			return res;
		}
		return process1(chs, i + 1);
	}

	public static int maxValue1(int[] weights, int[] values, int bag) {
		return process1(weights, values, 0, 0, bag);
	}

	// 背包问题-递归
	public static int process1(int[] weights, int[] values, int i, int alreadyweight, int bag) {
		if (alreadyweight > bag) {
			return 0;
		}

		if (i == weights.length) {
			return 0;
		}

		int w1 = process1(weights, values, i + 1, alreadyweight, bag);
		int w2 = values[i] + process1(weights, values, i + 1, alreadyweight + weights[i], bag);

		return Math.max(w1, w2);
	}

	// 背包问题-动态规划
	public static int maxValue2(int[] c, int[] p, int bag) {
		int[][] dp = new int[c.length + 1][bag + 1];

		for (int i = c.length - 1; i >= 0; i--) {

			for (int j = bag; j >= 0; j--) {

				dp[i][j] = dp[i + 1][j];
				if (j + c[i] <= bag) {
					dp[i][j] = Math.max(dp[i][j], p[i] + dp[i + 1][j + c[i]]);
				}
			}
		}
		return dp[0][0];
	}

	// 纸牌博弈-递归
	public static int win1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		return Math.max(f(arr, 0, arr.length - 1), s(arr, 0, arr.length - 1));
	}

	// 先手拿
	public static int f(int[] arr, int i, int j) {
		if (i == j) {
			return arr[i];
		}
		return Math.max(arr[i] + s(arr, i + 1, j), arr[j] + s(arr, i, j - 1));
	}

	// 后手拿
	public static int s(int[] arr, int i, int j) {
		if (i == j) {
			return 0;
		}
		return Math.min(f(arr, i + 1, j), f(arr, i, j - 1));
	}

	// 纸牌博弈-动态规划
	public static int win2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int[][] f = new int[arr.length][arr.length];
		int[][] s = new int[arr.length][arr.length];
		for (int j = 0; j < arr.length; j++) {
			f[j][j] = arr[j];
			for (int i = j - 1; i >= 0; i--) {
				f[i][j] = Math.max(arr[i] + s[i + 1][j], arr[j] + s[i][j - 1]);
				s[i][j] = Math.min(f[i + 1][j], f[i][j - 1]);
			}
		}
		return Math.max(f[0][arr.length - 1], s[0][arr.length - 1]);
	}

	// ---------------------------------------------------------rm8终-----------------------------------------------------

	// ---------------------------------------------------------zj1始-----------------------------------------------------

	// 长度为L的绳子最多覆盖几个点，请保证arr有序
	public static int maxPoint(int[] arr, int L) {
		int res = 1;
		for (int i = 0; i < arr.length; i++) {
			int nearest = nearestIndex(arr, i, arr[i] - L);
			res = Math.max(res, i - nearest + 1);
		}
		return res;
	}

	// 在arr[0..R]范围上，找满足>=value的最左位置
	public static int nearestIndex(int[] arr, int R, int value) {
		int L = 0;
		int index = R;
		while (L < R) {
			int mid = L + ((R - L) >> 1);
			if (arr[mid] >= value) {
				index = mid;
				R = mid - 1;
			} else {
				L = mid + 1;
			}
		}
		return index;
	}

	// ---------------------------------------------------------zj1终-----------------------------------------------------

	@Test
	public void test1() {
		Runnable runnable = new Runnable() {

			@Override
			public void run() {
				System.out.println("线程启动了");
			}
		};
		runnable.run();
	}

	/**
	 * 语法格式一：无参数，无返回值 () -> System.out.println("Hello Lambda!");
	 */
	@Test
	public void test2() {
		// “->”左边只有一个小括号，表示无参数，右边是Lambda体(就相当于实现了匿名内部类里面的方法了，(即就是一个可用的接口实现类了。))
		Runnable runnable = () -> System.out.println("线程启动了");
		runnable.run();
	}

	/**
	 * 语法格式二：有一个参数，并且无返回值 (x) -> System.out.println(x)
	 */
	@Test
	public void test3() {
		// 这个e就代表所实现的接口的方法的参数，
		Consumer<String> consumer = e -> System.out.println("ghijhkhi" + e);
		consumer.accept("woojopj");
	}

	@Test
	public void test4() {
		// Lambda 体中有多条语句，记得要用大括号括起来
		Comparator<Integer> com = (x, y) -> {
			System.out.println("函数式接口");
			return Integer.compare(x, y);
		};
		int compare = com.compare(100, 244);
		System.out.println(compare);
	}

	@Test
	public void test6() {
		Supplier<String> supplier = () -> "532323".substring(0, 2);
		System.out.println(supplier.get());
	}

	@Test
	public void test7() {
		Function<String, String> function = (x) -> x.substring(0, 2);
		System.out.println(function.apply("我是中国人"));
	}

	@Test
	public void test8() {
		Predicate<String> predicate = (x) -> x.length() > 5;
		System.out.println(predicate.test("12345678"));
		System.out.println(predicate.test("123"));
	}

}

class EqualExample {
	private int x;
	private int y;
	private int z;

	public EqualExample(int x, int y, int z) {
		this.x = x;
		this.y = y;
		this.z = z;
	}

	@Override
	public boolean equals(Object o) {
		// 1.检查是否为同一个对象的引用，如果是直接返回 true
		if (this == o)
			return true;
		// 2.检查是否是同一个类型，如果不是，直接返回 false
		if (o == null || getClass() != o.getClass())
			return false;
		// 3.将 Object 对象进行转型
		EqualExample that = (EqualExample) o;
		// 4.判断每个关键域是否相等
		if (x != that.x)
			return false;
		if (y != that.y)
			return false;
		return z == that.z;
	}
}